# -*- coding: utf-8 -*-
"""Inspirit Notebook

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WVfoa4d8ogXgybNmhlbIwlt0rWLBm1cQ
"""

!pip install yfinance

!pip install yfinance matplotlib

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

#setup
#code
ticker_name='DIS'
# function to fetch and prepare data for a given ticker
ticker = yf.Ticker(ticker_name) #import data
aapl_df = ticker.history(period="5Y") #get data from 5 year period in dataframe
aapl_df.drop(['High','Close','Volume','Dividends','Stock Splits'], axis=1, inplace=True) #only have two columns, not seven
open = np.empty(shape = (1259), dtype = float)
close = np.empty(shape = (1259), dtype = float)

open=aapl_df[['Open']].to_numpy()

print(open)#len(open) = 1257
#sliding window: window size 4, input of price of tues, wed, thurs, and will predict price on fri.

X = np.zeros((1260,4))
Y = [0]*1260

#1254 is exclusive, so 1253 is the index of most recent day
print(open[1256])
for i in range(1253):
  X[i] = [open[i][0],open[i+1][0],open[i+2][0], open[i+3][0]]
  Y[i] = open[i+4][0]

print(X[0])
print(Y[0])

#split data into training and testing data
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.33) #random state

print(X_train[0])
print(y_train[0])

from sklearn import datasets, linear_model
from sklearn.metrics import mean_squared_error, r2_score

# Create linear regression object
linear = linear_model.LinearRegression()

# Train the model using the training sets
linear.fit(X_train, y_train)

#TEST PREDICTION
linear_y_pred = linear.predict(X_test)
#TRAIN PREDICTION
linear_y_train_pred = linear.predict(X_train)
#TOTAL DATASET PREDICTION
linear_total_pred = linear.predict(X)

# The coefficients: p is price you had before, w is the coeffecients.
print("Coefficients: \n", linear.coef_)

print("Mean squared error (Linear train): %.2f" % mean_squared_error(y_train, linear_y_train_pred))

# The mean squared error; difference of predicted and actual data, you square it and then you take the average of all instances.
print("Mean squared error (Linear test): %.2f" % mean_squared_error(y_test, linear_y_pred))

print("Mean squared error (Linear total): %.2f" % mean_squared_error(Y, linear_total_pred))

#MSE OF TEST PREDICTION
mse_linear = mean_squared_error(y_test, linear_y_pred)

#MSE OF TOTAL PREDICTION
mse_lin_total = mean_squared_error(Y, linear_total_pred)

#w1p1 + w2p2 + w3p3 (Input)
#Don't think of linear regression model as a line, think of it as something where the output is the

inverse_mse_linear = 1/mse_linear

inv_mse_lin_total = 1/mse_lin_total

length = len(y_test)
print("Length of y_test: ", length)

start_day = length - 91
end_day = length - 1

plt.title("{} Linear Regression (Days {} to {})".format(ticker_name,start_day, end_day))
plt.xlabel("Days")
plt.ylabel("Price")
plt.plot(y_test[start_day:end_day], label="real price")
plt.plot(linear_y_pred[start_day:end_day], label="prediction")
plt.legend()

#MLP: Neural Network: Takes in the inputs and runs it through each connection(parameter) with the nodes in the hidden layers, the output is the sum of the numbers of the last hidden layers.
#import
from sklearn.neural_network import MLPRegressor
from sklearn.datasets import make_regression

#setting parameters
MLP = MLPRegressor(hidden_layer_sizes=(5, 5, 5,), max_iter=800).fit(X_train, y_train)
#TEST PRED
MLP_y_pred = MLP.predict(X_test)
#TRAIN PRED
MLP_y_train_pred = MLP.predict(X_train)
#TOTAL PRED
MLP_total_pred= MLP.predict(X)

#train mse
print("Mean squared error (MLP train): %.2f" % mean_squared_error(y_train, MLP_y_train_pred))
#test mse
print("Mean squared error (MLP test): %.2f" % mean_squared_error(y_test, MLP_y_pred))
#total mse
print("Mean squared error (MLP total): %.2f" % mean_squared_error(Y, MLP_total_pred))


#inverse mse
mse_mlp = mean_squared_error(y_test, MLP_y_pred)
inverse_mse_mlp = 1/mse_mlp

mse_mlp_total = mean_squared_error(Y, MLP_total_pred)
inv_mse_mlp_total = 1/mse_mlp_total

start_day = length - 91
end_day = length - 1 #-1 is most recent

plt.title("{} MLP Regression (Days {} to {})".format(ticker_name,start_day, end_day))
plt.xlabel("Days")
plt.ylabel("Price")
plt.plot(y_test[start_day:end_day], label = "real price")
plt.plot(MLP_y_pred[start_day:end_day], label = "prediction")
plt.legend()

#DecisionTree; If conditions
#import
from sklearn.tree import DecisionTreeRegressor

#setting parameters
DT = DecisionTreeRegressor(max_depth=8) #Max depth represents max conditions possible for DT model

DT.fit(X_train, y_train)
#TEST PRED
DT_y_pred = DT.predict(X_test)
#TRAIN PRED
DT_y_train_pred = DT.predict(X_train)
#TOTAL PRED
DT_total_pred = DT.predict(X)

#train mse
print("Mean squared error (DT train): %.2f" % mean_squared_error(y_train, DT_y_train_pred))
#test mse
print("Mean squared error (DT test): %.2f" % mean_squared_error(y_test, DT_y_pred))
#total mse
print("Mean squared error (DT total): %.2f" % mean_squared_error(Y, DT_total_pred))


#setting inverse mse
mse_dt = mean_squared_error(y_test, DT_y_pred)
inverse_mse_dt = 1/mse_dt

mse_dt_total = mean_squared_error(Y, DT_total_pred)
inv_mse_dt_total = 1/mse_dt_total

start_day = length - 91
end_day = length - 1

plt.title("{} Decision Tree Regression (Days {} to {})".format(ticker_name,start_day, end_day))
plt.xlabel("Days")
plt.ylabel("Price")
plt.plot(y_test[start_day:end_day], label = "real price")
plt.plot(DT_y_pred[start_day:end_day], label = "prediction")
plt.legend()

#RandomForest: Set of Decision trees, each one will predict something different and you will take the average, n_estimators is how many DTs you want
#import
from sklearn.ensemble import RandomForestRegressor

#setting parameters
RF = RandomForestRegressor(n_estimators=80, max_depth=8)

#training
RF.fit(X_train, y_train)

#TEST PRED
RF_y_pred = RF.predict(X_test)
#TRAIN PRED
RF_y_train_pred = RF.predict(X_train)
#TOTAL PRED
RF_total_pred = RF.predict(X)

#train mse
print("Mean squared error (RF train): %.2f" % mean_squared_error(y_train, RF_y_train_pred))
#test mse
print("Mean squared error (RF test): %.2f" % mean_squared_error(y_test, RF_y_pred))
#total mse
print("Mean squared error (RF total): %.2f" % mean_squared_error(Y, RF_total_pred))

mse_rf = mean_squared_error(y_test, RF_y_pred)

mse_rf_total = mean_squared_error(Y, RF_total_pred)

inverse_mse_rf = 1/mse_rf
inv_mse_rf_total = 1/mse_rf_total

start_day = length - 91
end_day = length - 1

plt.title("{} Random Forest Regression (Days {} to {})".format(ticker_name,start_day, end_day))
plt.xlabel("Days")
plt.ylabel("Price")
plt.plot(y_test[start_day:end_day], label = "real price")
plt.plot(RF_y_pred[start_day:end_day], label = "prediction")
plt.legend()

#regular avg
y_average = (linear_y_pred + MLP_y_pred + DT_y_pred + RF_y_pred)/4
y_train_avg = (linear_y_train_pred + MLP_y_train_pred + DT_y_train_pred + RF_y_train_pred)/4

print("MSE of regular avg (train): ", mean_squared_error(y_train, y_train_avg))

print("MSE of regular avg (test): ", mean_squared_error(y_test, y_average))
print()

# random weighted avg
y_weighted_avg = (linear_y_pred * 0.4 + MLP_y_pred * 0.1 + DT_y_pred * 0.2 + RF_y_pred * 0.3)
print("MSE of random weighted avg (test): ", mean_squared_error(y_test, y_weighted_avg))
print()

#calculated weighted avg of test dataset
mse = inverse_mse_linear + inverse_mse_dt + inverse_mse_mlp + inverse_mse_rf
#Weighted avg of total dataset
mse_total = inv_mse_lin_total + inv_mse_dt_total + inv_mse_mlp_total + inv_mse_rf_total

#y_test=========================================================================
lin_weight = inverse_mse_linear/mse
mlp_weight = inverse_mse_mlp/mse
dt_weight = inverse_mse_dt/mse
rf_weight = inverse_mse_rf/mse

print("Linear weight (y_test): ", lin_weight)
print("MLP weight (y_test): ", mlp_weight)
print("DT weight (y_test): ", dt_weight)
print("RF weight (y_test): ", rf_weight)
print()

#total==========================================================================
lin_total_weight = inv_mse_lin_total/mse_total
mlp_total_weight = inv_mse_mlp_total/mse_total
dt_total_weight = inv_mse_dt_total/mse_total
rf_total_weight = inv_mse_rf_total/mse_total

print("Linear weight (total): ", lin_total_weight)
print("MLP weight (total): ", mlp_total_weight)
print("DT weight (total): ", dt_total_weight)
print("RF weight (total): ", rf_total_weight)
print()

#===============================================================================

y_weighted_avg_final = (linear_y_pred * lin_weight + MLP_y_pred * mlp_weight + DT_y_pred * dt_weight + RF_y_pred * rf_weight)

y_weighted_avg_total = (linear_total_pred * lin_total_weight + MLP_total_pred * mlp_total_weight + DT_total_pred * dt_total_weight + RF_total_pred * rf_total_weight)

print("MSE of weighted predictions (y_test): ", mean_squared_error(y_test, y_weighted_avg_final))
print("MSE of weighted predictions (total): ", mean_squared_error(Y, y_weighted_avg_total))

#dataset details and metrics
print("MSE test: ", mean_squared_error(y_test, y_weighted_avg_final))
print("MSE total: ", mean_squared_error(Y, y_weighted_avg_total))
print()

print("Weighted avg prediction length (of y_test): ", y_weighted_avg_final.size)
print("y_test: ", (len(y_test)))
print()

print("Weighted avg prediction length (of total): ", y_weighted_avg_total.size)
print("Y data length: ", len(Y))

#OPEN PRICE TODAY + real price

today = len(open) - 4
x_from_today = today - 90
print("Open price today: ", Y[today-4])
print("Open price today: ", open[today])

plt.title("{} 5Y Real price".format(ticker_name))
plt.plot(open, label = "real price")
plt.xlabel("Days")
plt.ylabel("Price")
plt.legend()

#OPEN PRICE TODAY

days = 5
today = len(open) - 1
x_from_today = today - days
#print(Y[today-4]) actual open price today saved in different index in Y dataset
#print(open[today]) actual open price today

#===============================================================================

tomorrow_data = np.array([open[-4], open[-3], open[-2], open[-1]])
tomorrow_data = tomorrow_data.reshape(1, -1)

tmr_lr_pred = linear.predict(tomorrow_data)
tmr_mlp_pred = MLP.predict(tomorrow_data)
tmr_dt_pred = DT.predict(tomorrow_data)
tmr_rf_pred = RF.predict(tomorrow_data)

tmr_total_pred = (tmr_lr_pred * lin_total_weight + tmr_mlp_pred * mlp_total_weight + tmr_dt_pred * dt_total_weight + tmr_rf_pred * rf_total_weight)
tmr_pred = float(tmr_total_pred[0])
y_weighted_avg_total[today-3] = tmr_pred


#troubleshoot

#five days ago
print("Prediction for five days ago:", y_weighted_avg_total[today-9])
print("Real price five days ago: ", open[today-5])
print()

#four days ago
print("Prediction for four days ago:", y_weighted_avg_total[today-8])
print("Real price four days ago: ", open[today-4])
print()

#three days ago
print("Prediction for three days ago:", y_weighted_avg_total[today-7])
print("Real price three days ago: ", open[today-3])
print()

#two days ago
print("Prediction for two days ago:", y_weighted_avg_total[today-6])
print("Real price two days ago: ", open[today-2])
print()

#yesterday
print("Prediction for yesterday:", y_weighted_avg_total[today-5])
print("Real price yesterday: ", open[today-1])
print()

#today
print("Prediction for today:", y_weighted_avg_total[today-4])
print("Real price today: ", open[today])
print()

#prediction
print("Prediction for tomorrow: ", tmr_pred)
print()

#===============================================================================

plt.title("{} last {} day(s) real price vs. prediction".format(ticker_name, days))
plt.plot(open[x_from_today:today], label = "real price")
plt.plot(y_weighted_avg_total[x_from_today-3:today-2], label = "prediction")
#Prediction index is shifted back by 3 because of previous days
plt.xlabel("Days")
plt.ylabel("Price")
plt.legend()

#COMBINED PREDICTION FOR TOTAL
#variables======================================================================
budget = 1000
stocks = 0
amount = 1
showGraph = False
predictions = y_weighted_avg_total

#setting data for tomorrows prediction==========================================
tomorrow_data = np.array([open[-4], open[-3], open[-2], open[-1]])
tomorrow_data = tomorrow_data.reshape(1, -1)

tmr_lr_pred = linear.predict(tomorrow_data)
tmr_mlp_pred = MLP.predict(tomorrow_data)
tmr_dt_pred = DT.predict(tomorrow_data)
tmr_rf_pred = RF.predict(tomorrow_data)

tmr_total_pred = (tmr_lr_pred * lin_total_weight + tmr_mlp_pred * mlp_total_weight + tmr_dt_pred * dt_total_weight + tmr_rf_pred * rf_total_weight)
tmr_pred = float(tmr_total_pred[0])
predictions[1253] = tmr_pred
print(tmr_pred)

#===============================================================================

for i in range(today-3):
  if predictions[i+1] > Y[i]: #prediction i+1 returns next day, Y should be i
    if budget >= Y[i]*amount:
      budget -= Y[i]*amount
      stocks += amount
      if showGraph == True:
        print("Day: ", i, " Budget: ", budget, " stocks held: ", stocks-amount, "+ ", amount,  "=", stocks, " prediction(next day): ", predictions[i+1], " Cost(today): ", Y[i])
  else:
    if stocks > 0:
      budget += Y[i]*amount
      stocks -= amount
      if showGraph == True:
        print("Day: ", i, " Budget: ", budget, " stocks held: ", stocks+amount, "-", amount,  "=", stocks, " prediction(next day): ", predictions[i+1], "Cost(today): ", Y[i])
  if i == today-4:
    while stocks > 0:
      budget += Y[i]
      stocks -= 1

#===============================================================================

print(budget)
print(stocks)

#LINEAR MODEL PREDICTION FOR TOTAL
#variables======================================================================
budget = 1000
stocks = 0
predictions = linear_total_pred

#===============================================================================

for i in range(today-3):
  if predictions[i+1] > Y[i]: #prediction i+1 returns next day, Y should be i
    if budget >= Y[i]*amount:
      budget -= Y[i]*amount
      stocks += amount
      #print("Day: ", i, " Budget: ", budget, " stocks held: ", stocks-amount, "+ ", amount,  "=", stocks, " prediction(next day): ", predictions[i+1], " Cost(today): ", Y[i])
  else:
    if stocks > 0:
      budget += Y[i]*amount
      stocks -= amount
      #print("Day: ", i, " Budget: ", budget, " stocks held: ", stocks+amount, "-", amount,  "=", stocks, " prediction(next day): ", predictions[i+1], "Cost(today): ", Y[i])
  if i == today-4:
    while stocks > 0:
      budget += Y[i]
      stocks -= 1

#===============================================================================

print(budget)
print(stocks)

#MLP PREDICTIONS FOR TOTAL
#variables======================================================================
budget = 1000
stocks = 0
predictions = MLP_total_pred

#===============================================================================

for i in range(today-3):
  if predictions[i+1] > Y[i]: #prediction i+1 returns next day, Y should be i
    if budget >= Y[i]*amount:
      budget -= Y[i]*amount
      stocks += amount
      #print("Day: ", i, " Budget: ", budget, " stocks held: ", stocks-amount, "+ ", amount,  "=", stocks, " prediction(next day): ", predictions[i+1], " Cost(today): ", Y[i])
  else:
    if stocks > 0:
      budget += Y[i]*amount
      stocks -= amount
      #print("Day: ", i, " Budget: ", budget, " stocks held: ", stocks+amount, "-", amount,  "=", stocks, " prediction(next day): ", predictions[i+1], "Cost(today): ", Y[i])
  if i == today-4:
    while stocks > 0:
      budget += Y[i]
      stocks -= 1

#===============================================================================

print(budget)
print(stocks)

#DT PREDICTIONS FOR TOTAL
#variables======================================================================
budget = 1000
stocks = 0
predictions = DT_total_pred

for i in range(today-3):
  if predictions[i+1] > Y[i]: #prediction i+1 returns next day, Y should be i
    if budget >= Y[i]*amount:
      budget -= Y[i]*amount
      stocks += amount
      #print("Day: ", i, " Budget: ", budget, " stocks held: ", stocks-amount, "+ ", amount,  "=", stocks, " prediction(next day): ", predictions[i+1], " Cost(today): ", Y[i])
  else:
    if stocks > 0:
      budget += Y[i]*amount
      stocks -= amount
      #print("Day: ", i, " Budget: ", budget, " stocks held: ", stocks+amount, "-", amount,  "=", stocks, " prediction(next day): ", predictions[i+1], "Cost(today): ", Y[i])
  if i == today-4:
    while stocks > 0:
      budget += Y[i]
      stocks -= 1

#===============================================================================

print(budget)
print(stocks)

#RF PREDICTIONS FOR TOTAL
#variables======================================================================
budget = 1000
stocks = 0
amount = 1

predictions = RF_total_pred

for i in range(today-3):
  if predictions[i+1] > Y[i]: #prediction i+1 returns next day, Y should be i
    if budget >= Y[i]*amount:
      budget -= Y[i]*amount
      stocks += amount
      #print("Day: ", i, " Budget: ", budget, " stocks held: ", stocks-amount, "+ ", amount,  "=", stocks, " prediction(next day): ", predictions[i+1], " Cost(today): ", Y[i])
  else:
    if stocks > 0:
      budget += Y[i]*amount
      stocks -= amount
      #print("Day: ", i, " Budget: ", budget, " stocks held: ", stocks+amount, "-", amount,  "=", stocks, " prediction(next day): ", predictions[i+1], "Cost(today): ", Y[i])
  if i == today-4:
    while stocks > 0:
      budget += Y[i]
      stocks -= 1

print(budget)
print(stocks)

#constant updating MSE
num_list = []
w_lin = 1/3
w_mlp = 1/3
w_rf = 1/3

for i in range(len(X_test)):
  num_list.append(linear_y_pred[i] * w_lin + MLP_y_pred[i] * w_mlp + RF_y_pred[i] * w_rf)
  #error squared
  error_lin = (linear_y_pred[i] - y_test[i])**2
  error_mlp = (MLP_y_pred[i] - y_test[i])**2
  error_rf = (RF_y_pred[i] - y_test[i])**2
  #weights
  w_lin = w_lin/(2**error_lin)
  w_mlp = w_mlp/(2**error_mlp)
  w_rf = w_rf/(2**error_rf)
  sum = w_lin + w_mlp + w_rf
  #normalize
  w_lin = w_lin/sum
  w_mlp = w_mlp/sum
  w_rf = w_rf/sum

#TOMORROW'S PREDICTION PRICE
tomorrow_data = np.array([open[-4], open[-3], open[-2], open[-1]])
tomorrow_data = tomorrow_data.reshape(1, -1)

tmr_lr_pred = linear.predict(tomorrow_data)
tmr_mlp_pred = MLP.predict(tomorrow_data)
tmr_dt_pred = DT.predict(tomorrow_data)
tmr_rf_pred = RF.predict(tomorrow_data)

tmr_total_pred = (tmr_lr_pred * lin_total_weight + tmr_mlp_pred * mlp_total_weight + tmr_dt_pred * dt_total_weight + tmr_rf_pred * rf_total_weight)

print(tmr_total_pred)